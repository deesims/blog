---
layout: post
title:  "What I learned studying Computer Science"
---

### Introduction

I would like to relay to you my academic experience studying Computer Science in the heart of Canada's capital, at University of Ottawa. I wanted to talk about this and relay to you year by year, the sort of things you'll be exposed to in Computer Science and whether or not this is something you would enjoy learning, as I also enjoyed. Parts of it of course, as every degree gets a little head of itself, for good and bad reasons but we will talk about it.

### Background

I suppose I should start with what does it take to get into a Bachelor of Science in Computer Science first, the **prerequisites** and the sort of mindset you need to have to tackle on this vision.

Of course the requirmenets to get in, will vary province by province, state by state, country by country. I went to Highschool here in the capital, and so my experience has been this. You'll need an understanding of functions, calculus, binary arithmetic and a deep understanding of the scientific method. Programming is all about the scientific method. Hypothesis, procedure, conduction of the expertiment, gathering of data through the procedure, analysing the data and based on the analysis conclude the accuracy of your hypothesis. Every line of code will result in a new scientific experiment. If you do not like experimentation, then this is definetely not for you. Software, code, and design is proned to bugs. No product can be designed from scratch without error.

I got accepted into University of Ottawa in 2015. I was placed in an Honours program which is a deeper specialization in the field, that is suppose to prep you for grad school with emphasis on research in your final year. Little did I know about this option, I went in anyways.

### First Year

My first year at university was definetely challenging to say the least. You are in some ways, being tested on sheer willingness to stay, rather than the intellectual creativity that you might have. This was my first concern about academia, that it scares people into never doing it again. Finding out the truth to most people is actually a fun process, but when hit with rules and regulations and rushed deadlines, becomes a dull one. 

<p align="center">
  <img height="60%" width="60%" src="https://www.atnyla.com/library/images-tutorials/various-data-types.png">
</p>

Nonetheless, first year is a time of exposure. You are introduced to a more formal approach to Linear Algebra and Calculus including proofs, you begin studying Python and Java, you start to hear terms like 'object-oriented programming', 'data types and structures', 'ints, strings and bools'. You jump into fundamentals of set theory. You start to build logical circuits for a small processor. You start to see code, simple yet effective code. Clean code, solutions to problems that are as efficient as humans can make it. My expectations of this year were shattered, I thought I would learn 10 new programming languages that we all love and know, that I would learn how to use software that no one knows how to use, but the road turned out to be quite different. I saw myself as a coder, and that was a mistake. This is not a degree for the practical go-people, this is a theoretical field, a mix of mathematical proofs, linguistics and engineering.

### Second Year

My second year, was probably the one I learnt most in. I'm not sure if it was due to my adaptation or if the material has become more specialized, probably both. You learn sorting algorithms, graph theory and how to conduct algorithmic analysis using Big-O notation. You learn more about what constitutes a programming language and what is a programming paradigm, rather than learning some syntax and a few examples. 


<p align="center">
  <img src="https://www.learncomputerscienceonline.com/wp-content/uploads/2019/09/Microprocessor-CPU-Processor.jpg">
</p>

You learn the basics of CPU, and its smaller parts like ALU and CU which I found deeply revealing. You learn about registers and addresses, how to encode and decode information, how a sequence of bits can transfer to a display of pixels, etc. This was also the year, in which proofs are introduced at a deeper level. Mathematical proofs are not joke man, and if I ever had to think about something, it was proving a true statement that I know is true from childhood, but cannot prove for the life of me. Simple things like (2 * n) will you give an even number, sounds pretty trivial, but the proof isn't so. The inductive step of +1 was not trivial. Lots of maths go into computing, hidden from us, for usability reasons. Algorithms and data structures is the most important thing to learn if you want to go into the job market. More importantly, time and space complexity of algorithms is even more important. 


<p align="center">
  <img height="50%" width="50%" src="https://media.springernature.com/original/springer-static/image/chp%3A10.1007%2F978-1-4842-3988-9_1/MediaObjects/465726_1_En_1_Fig1_HTML.jpg">
</p>

Doing Big-Oh analysis will help you decide which algorithm performs more steps, deciding which algorithm we should use to tackle on a given problem. We want to be correct in our application, but we also want to be fast and light.


### Third Year

TBC
